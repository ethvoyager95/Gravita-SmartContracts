# -*- coding: utf-8 -*-
"""Baseline vs Alternative V2 Copy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NNPdiKfO3950MuAGyIXTNrr4OMliINKb

# Parameters and Initialization
"""

import random
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import matplotlib.pyplot as plt
import scipy.stats
from plotly.subplots import make_subplots

# policy functions
rate_issuance = 0.01
rate_redemption = 0.01
base_rate_initial = 0

# global variables
period = 24 * 365
month = 24 * 30
day = 24

# ether price
price_ether_initial = 1000
price_ether = [price_ether_initial]
sd_ether = 0.02
drift_ether = 0

# GRVT price & airdrop
price_GRVT_initial = 1
price_GRVT = [price_GRVT_initial]
sd_GRVT = 0.005
drift_GRVT = 0.0035
# reduced for now. otherwise the initial return too high
quantity_GRVT_airdrop = 500
supply_GRVT = [0]
GRVT_total_supply = 100000000

# PE ratio
PE_ratio = 50

# natural rate
natural_rate_initial = 0.2
natural_rate = [natural_rate_initial]
sd_natural_rate = 0.002

# stability pool
initial_return = 0.2
return_stability = [initial_return]
sd_return = 0.001
sd_stability = 0.001
drift_stability = 1.002
theta = 0.001

# liquidity pool & redemption pool
sd_liquidity = 0.001
sd_redemption = 0.001
drift_liquidity = 1.0003
redemption_star = 0.8
delta = -20

# close vessels
sd_closevessels = 0.5
# sensitivity to VUSD price
beta = 0.2

# open vessels
distribution_parameter1_ether_quantity = 10
distribution_parameter2_ether_quantity = 500
distribution_parameter1_CR = 1.1
distribution_parameter2_CR = 0.1
distribution_parameter3_CR = 16
distribution_parameter1_inattention = 4
distribution_parameter2_inattention = 0.08
sd_openvessels = 0.5
n_steady = 0.5
initial_open = 10

# sensitivity to VUSD price & issuance fee
alpha = 0.3

# number of runs in simulation
n_sim = 8640

"""# Exogenous Factors

Ether Price
"""

# ether price
for i in range(1, period):
    random.seed(2019375 + 10000 * i)
    shock_ether = random.normalvariate(0, sd_ether)
    price_ether.append(price_ether[i - 1] * (1 + shock_ether) * (1 + drift_ether))

"""Natural Rate"""

# natural rate
for i in range(1, period):
    random.seed(201597 + 10 * i)
    shock_natural = random.normalvariate(0, sd_natural_rate)
    natural_rate.append(natural_rate[i - 1] * (1 + shock_natural))

"""GRVT Price - First Month"""

# GRVT price
for i in range(1, month):
    random.seed(2 + 13 * i)
    shock_GRVT = random.normalvariate(0, sd_GRVT)
    price_GRVT.append(price_GRVT[i - 1] * (1 + shock_GRVT) * (1 + drift_GRVT))

"""# Troves

Liquidate Troves
"""


def liquidate_vessels(vessels, index, data):
    vessels["CR_current"] = (
        vessels["Ether_Price"] * vessels["Ether_Quantity"] / vessels["Supply"]
    )
    price_USDV_previous = data.loc[index - 1, "Price_USDV"]
    price_GRVT_previous = data.loc[index - 1, "price_GRVT"]
    stability_pool_previous = data.loc[index - 1, "stability"]

    vessels_liquidated = vessels[vessels.CR_current < 1.1]
    vessels = vessels[vessels.CR_current >= 1.1]
    debt_liquidated = vessels_liquidated["Supply"].sum()
    ether_liquidated = vessels_liquidated["Ether_Quantity"].sum()
    n_liquidate = vessels_liquidated.shape[0]
    vessels = vessels.reset_index(drop=True)

    liquidation_gain = (
        ether_liquidated * price_ether_current - debt_liquidated * price_USDV_previous
    )
    airdrop_gain = price_GRVT_previous * quantity_GRVT_airdrop

    np.random.seed(2 + index)
    shock_return = np.random.normal(0, sd_return)
    if index <= day:
        return_stability = initial_return * (1 + shock_return)
    elif index <= month:
        # min function to rule out the large fluctuation caused by the large but temporary liquidation gain in a particular period
        return_stability = min(
            0.5,
            365
            * (
                data.loc[index - day : index, "liquidation_gain"].sum()
                + data.loc[index - day : index, "airdrop_gain"].sum()
            )
            / (price_USDV_previous * stability_pool_previous),
        )
    else:
        return_stability = (
            (365 / 30)
            * (
                data.loc[index - month : index, "liquidation_gain"].sum()
                + data.loc[index - month : index, "airdrop_gain"].sum()
            )
            / (price_USDV_previous * stability_pool_previous)
        )

    return [
        vessels,
        return_stability,
        debt_liquidated,
        ether_liquidated,
        liquidation_gain,
        airdrop_gain,
        n_liquidate,
    ]


"""Close Troves"""


def close_vessels(vessels, index2, price_USDV_previous):
    np.random.seed(208 + index2)
    shock_closevessels = np.random.normal(0, sd_closevessels)
    n_vessels = vessels.shape[0]

    if index2 <= 240:
        number_closevessels = np.random.uniform(0, 1)
    elif price_USDV_previous >= 1:
        number_closevessels = max(0, n_steady * (1 + shock_closevessels))
    else:
        number_closevessels = (
            max(0, n_steady * (1 + shock_closevessels))
            + beta * (1 - price_USDV_previous) * n_vessels
        )

    number_closevessels = int(round(number_closevessels))

    random.seed(293 + 100 * index2)
    drops = list(random.sample(range(len(vessels)), number_closevessels))
    vessels = vessels.drop(drops)
    vessels = vessels.reset_index(drop=True)
    if len(vessels) < number_closevessels:
        number_closevessels = -999

    return [vessels, number_closevessels]


"""Adjust Troves"""


def adjust_vessels(vessels, index):
    issuance_USDV_adjust = 0
    random.seed(57984 - 3 * index)
    ratio = random.uniform(0, 1)
    for i in range(0, vessels.shape[0]):
        random.seed(187 * index + 3 * i)
        working_vessel = vessels.iloc[i, :]
        p = random.uniform(0, 1)
        check = (working_vessel["CR_current"] - working_vessel["CR_initial"]) / (
            working_vessel["CR_initial"] * working_vessel["Rational_inattention"]
        )

        # A part of the vessels are adjusted by adjusting debt
        if p >= ratio:
            if check < -1:
                working_vessel["Supply"] = (
                    working_vessel["Ether_Price"]
                    * working_vessel["Ether_Quantity"]
                    / working_vessel["CR_initial"]
                )
            if check > 2:
                supply_new = (
                    working_vessel["Ether_Price"]
                    * working_vessel["Ether_Quantity"]
                    / working_vessel["CR_initial"]
                )
                issuance_USDV_adjust = issuance_USDV_adjust + rate_issuance * (
                    supply_new - working_vessel["Supply"]
                )
                working_vessel["Supply"] = supply_new
        # Another part of the vessels are adjusted by adjusting collaterals
        if p < ratio and (check < -1 or check > 2):
            working_vessel["Ether_Quantity"] = (
                working_vessel["CR_initial"]
                * working_vessel["Supply"]
                / working_vessel["Ether_Price"]
            )

        vessels.loc[i] = working_vessel
    return [vessels, issuance_USDV_adjust]


"""Open Troves"""


def open_vessels(vessels, index1, price_USDV_previous):
    random.seed(2019 * index1)
    issuance_USDV_open = 0
    shock_openvessels = random.normalvariate(0, sd_openvessels)
    n_vessels = vessels.shape[0]

    if index1 <= 0:
        number_openvessels = initial_open
    elif price_USDV_previous <= 1 + rate_issuance:
        number_openvessels = max(0, n_steady * (1 + shock_openvessels))
    else:
        number_openvessels = (
            max(0, n_steady * (1 + shock_openvessels))
            + alpha * (price_USDV_previous - rate_issuance - 1) * n_vessels
        )

    number_openvessels = int(round(float(number_openvessels)))

    for i in range(0, number_openvessels):
        price_ether_current = price_ether[index1]

        np.random.seed(2033 + index1 + i * i)
        CR_ratio = (
            distribution_parameter1_CR
            + distribution_parameter2_CR
            * np.random.chisquare(df=distribution_parameter3_CR)
        )

        np.random.seed(20 + 10 * i + index1)
        quantity_ether = np.random.gamma(
            distribution_parameter1_ether_quantity,
            scale=distribution_parameter2_ether_quantity,
        )

        np.random.seed(209870 - index1 + i * i)
        rational_inattention = np.random.gamma(
            distribution_parameter1_inattention,
            scale=distribution_parameter2_inattention,
        )

        supply_vessel = price_ether_current * quantity_ether / CR_ratio
        issuance_USDV_open = issuance_USDV_open + rate_issuance * supply_vessel

        new_row = {
            "Ether_Price": price_ether_current,
            "Ether_Quantity": quantity_ether,
            "CR_initial": CR_ratio,
            "Supply": supply_vessel,
            "Rational_inattention": rational_inattention,
            "CR_current": CR_ratio,
        }
        vessels = vessels.append(new_row, ignore_index=True)

    return [vessels, number_openvessels, issuance_USDV_open]


"""# VUSD Market

Stability Pool
"""


def stability_update(stability_pool_previous, return_previous, index):
    np.random.seed(27 + 3 * index)
    shock_stability = np.random.normal(0, sd_stability)
    natural_rate_current = natural_rate[index]
    if index <= month:
        stability_pool = (
            stability_pool_previous
            * (drift_stability + shock_stability)
            * (1 + return_previous - natural_rate_current) ** theta
        )
    else:
        stability_pool = (
            stability_pool_previous
            * (1 + shock_stability)
            * (1 + return_previous - natural_rate_current) ** theta
        )
    return [stability_pool]


"""VUSD Price, liquidity pool, and redemption"""


def price_stabilizer(vessels, index, data, stability_pool, n_open):
    issuance_USDV_stabilizer = 0
    redemption_fee = 0
    n_redempt = 0
    redempted = 0
    redemption_pool = 0
    # Calculating Price
    supply = vessels["Supply"].sum()
    np.random.seed(20 * index)
    shock_liquidity = np.random.normal(0, sd_liquidity)
    liquidity_pool_previous = float(data["liquidity"][index - 1])
    price_USDV_previous = float(data["Price_USDV"][index - 1])
    price_USDV_current = price_USDV_previous * (
        (supply - stability_pool)
        / (liquidity_pool_previous * (drift_liquidity + shock_liquidity))
    ) ** (1 / delta)

    # Liquidity Pool
    liquidity_pool = supply - stability_pool

    # Stabilizer
    # Ceiling Arbitrageurs
    if price_USDV_current > 1.1 + rate_issuance:
        # supply_current = sum(vessels['Supply'])
        supply_wanted = (
            stability_pool
            + liquidity_pool_previous
            * (drift_liquidity + shock_liquidity)
            * ((1.1 + rate_issuance) / price_USDV_previous) ** delta
        )
        supply_vessel = supply_wanted - supply

        CR_ratio = 1.1
        rational_inattention = 0.1
        quantity_ether = supply_vessel * CR_ratio / price_ether_current
        issuance_USDV_stabilizer = rate_issuance * supply_vessel

        new_row = {
            "Ether_Price": price_ether_current,
            "Ether_Quantity": quantity_ether,
            "CR_initial": CR_ratio,
            "Supply": supply_vessel,
            "Rational_inattention": rational_inattention,
            "CR_current": CR_ratio,
        }
        vessels = vessels.append(new_row, ignore_index=True)
        price_USDV_current = 1.1 + rate_issuance
        # missing in the previous version
        liquidity_pool = supply_wanted - stability_pool
        n_open = n_open + 1

    # Floor Arbitrageurs
    if price_USDV_current < 1 - rate_redemption:
        np.random.seed(30 * index)
        shock_redemption = np.random.normal(0, sd_redemption)
        redemption_ratio = redemption_star * (1 + shock_redemption)

        # supply_current = sum(vessels['Supply'])
        supply_target = (
            stability_pool
            + liquidity_pool_previous
            * (drift_liquidity + shock_liquidity)
            * ((1 - rate_redemption) / price_USDV_previous) ** delta
        )
        supply_diff = supply - supply_target
        if supply_diff < redemption_ratio * liquidity_pool:
            redemption_pool = supply_diff
            # liquidity_pool = liquidity_pool - redemption_pool
            price_USDV_current = 1 - rate_redemption
        else:
            redemption_pool = redemption_ratio * liquidity_pool
            # liquidity_pool = (1-redemption_ratio)*liquidity_pool
            price_USDV_current = price_USDV_previous * (
                liquidity_pool
                / (liquidity_pool_previous * (drift_liquidity + shock_liquidity))
            ) ** (1 / delta)

        # Shutting down the riskiest vessels
        vessels = vessels.sort_values(by="CR_current", ascending=True)
        quantity_working_vessel = vessels["Supply"][vessels.index[0]]
        redempted = quantity_working_vessel
        while redempted <= redemption_pool:
            vessels = vessels.drop(vessels.index[0])
            quantity_working_vessel = vessels["Supply"][vessels.index[0]]
            redempted = redempted + quantity_working_vessel
            n_redempt = n_redempt + 1

        # Residuals
        redempted = redempted - quantity_working_vessel
        residual = redemption_pool - redempted
        wk = vessels.index[0]
        vessels["Supply"][wk] = vessels["Supply"][wk] - residual
        vessels["Ether_Quantity"][wk] = (
            vessels["Ether_Quantity"][wk] - residual / price_ether_current
        )
        vessels["CR_current"][wk] = (
            price_ether_current * vessels["Ether_Quantity"][wk] / vessels["Supply"][wk]
        )

        # Redemption Fee
        redemption_fee = rate_redemption * redemption_pool

    vessels = vessels.reset_index(drop=True)
    return [
        price_USDV_current,
        liquidity_pool,
        vessels,
        issuance_USDV_stabilizer,
        redemption_fee,
        n_redempt,
        redemption_pool,
        n_open,
    ]


"""# GRVT Market"""


def GRVT_market(index, data):
    quantity_GRVT = (100000000 / 3) * (1 - 0.5 ** (index / period))
    np.random.seed(2 + 3 * index)
    if index <= month:
        price_GRVT_current = price_GRVT[index - 1]
        annualized_earning = (index / month) ** 0.5 * np.random.normal(
            200000000, 500000
        )
    else:
        revenue_issuance = data.loc[index - month : index, "issuance_fee"].sum()
        revenue_redemption = data.loc[index - month : index, "redemption_fee"].sum()
        annualized_earning = 365 * (revenue_issuance + revenue_redemption) / 30
        # discountin factor to factor in the risk in early days
        discount = index / period
        price_GRVT_current = (
            discount * PE_ratio * annualized_earning / GRVT_total_supply
        )

    MC_GRVT_current = price_GRVT_current * quantity_GRVT
    return [price_GRVT_current, annualized_earning, MC_GRVT_current]


"""# Simulation Program"""

# Defining Initials
initials = {
    "Price_USDV": [1.00],
    "Price_Ether": [price_ether_initial],
    "n_open": [initial_open],
    "n_close": [0],
    "n_liquidate": [0],
    "n_redempt": [0],
    "n_vessels": [initial_open],
    "stability": [0],
    "liquidity": [0],
    "redemption_pool": [0],
    "supply_USDV": [0],
    "return_stability": [initial_return],
    "airdrop_gain": [0],
    "liquidation_gain": [0],
    "issuance_fee": [0],
    "redemption_fee": [0],
    "price_GRVT": [price_GRVT_initial],
    "MC_GRVT": [0],
    "annualized_earning": [0],
}
data = pd.DataFrame(initials)
vessels = pd.DataFrame(
    {
        "Ether_Price": [],
        "Ether_Quantity": [],
        "CR_initial": [],
        "Supply": [],
        "Rational_inattention": [],
        "CR_current": [],
    }
)
result_open = open_vessels(vessels, 0, data["Price_USDV"][0])
vessels = result_open[0]
issuance_USDV_open = result_open[2]
data.loc[0, "issuance_fee"] = issuance_USDV_open * initials["Price_USDV"][0]
data.loc[0, "supply_USDV"] = vessels["Supply"].sum()
data.loc[0, "liquidity"] = 0.5 * vessels["Supply"].sum()
data.loc[0, "stability"] = 0.5 * vessels["Supply"].sum()

# Simulation Process
for index in range(1, n_sim):
    # exogenous ether price input
    price_ether_current = price_ether[index]
    vessels["Ether_Price"] = price_ether_current
    price_USDV_previous = data.loc[index - 1, "Price_USDV"]
    price_GRVT_previous = data.loc[index - 1, "price_GRVT"]

    # vessel liquidation & return of stability pool
    result_liquidation = liquidate_vessels(vessels, index, data)
    vessels = result_liquidation[0]
    return_stability = result_liquidation[1]
    debt_liquidated = result_liquidation[2]
    ether_liquidated = result_liquidation[3]
    liquidation_gain = result_liquidation[4]
    airdrop_gain = result_liquidation[5]
    n_liquidate = result_liquidation[6]

    # close vessels
    result_close = close_vessels(vessels, index, price_USDV_previous)
    vessels = result_close[0]
    n_close = result_close[1]
    # if n_close<0:
    #  break

    # adjust vessels
    result_adjustment = adjust_vessels(vessels, index)
    vessels = result_adjustment[0]
    issuance_USDV_adjust = result_adjustment[1]

    # open vessels
    result_open = open_vessels(vessels, index, price_USDV_previous)
    vessels = result_open[0]
    n_open = result_open[1]
    issuance_USDV_open = result_open[2]

    # Stability Pool
    stability_pool = stability_update(
        data.loc[index - 1, "stability"], return_stability, index
    )[0]

    # Calculating Price, Liquidity Pool, and Redemption
    result_price = price_stabilizer(vessels, index, data, stability_pool, n_open)
    price_USDV_current = result_price[0]
    liquidity_pool = result_price[1]
    vessels = result_price[2]
    issuance_USDV_stabilizer = result_price[3]
    redemption_fee = result_price[4]
    n_redempt = result_price[5]
    redemption_pool = result_price[6]
    n_open = result_price[7]
    if liquidity_pool < 0:
        break

    # GRVT Market
    result_GRVT = GRVT_market(index, data)
    price_GRVT_current = result_GRVT[0]
    annualized_earning = result_GRVT[1]
    MC_GRVT_current = result_GRVT[2]

    # Summary
    issuance_fee = price_USDV_current * (
        issuance_USDV_adjust + issuance_USDV_open + issuance_USDV_stabilizer
    )
    n_vessels = vessels.shape[0]
    supply_USDV = vessels["Supply"].sum()
    if index >= month:
        price_GRVT.append(price_GRVT_current)

    new_row = {
        "Price_USDV": float(price_USDV_current),
        "Price_Ether": float(price_ether_current),
        "n_open": float(n_open),
        "n_close": float(n_close),
        "n_liquidate": float(n_liquidate),
        "n_redempt": float(n_redempt),
        "n_vessels": float(n_vessels),
        "stability": float(stability_pool),
        "liquidity": float(liquidity_pool),
        "redemption_pool": float(redemption_pool),
        "supply_USDV": float(supply_USDV),
        "issuance_fee": float(issuance_fee),
        "redemption_fee": float(redemption_fee),
        "airdrop_gain": float(airdrop_gain),
        "liquidation_gain": float(liquidation_gain),
        "return_stability": float(return_stability),
        "annualized_earning": float(annualized_earning),
        "MC_GRVT": float(MC_GRVT_current),
        "price_GRVT": float(price_GRVT_current),
    }
    data = data.append(new_row, ignore_index=True)
    if price_USDV_current < 0:
        break

"""#**Exhibition**"""

data


def linevis(data, measure):
    fig = px.line(data, x=data.index / 720, y=measure, title=measure + " dynamics")
    fig.show()


fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["Price_USDV"], name="VUSD Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["Price_Ether"], name="Ether Price"),
    secondary_y=True,
)
fig.update_layout(title_text="Price Dynamics of VUSD and Ether")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="VUSD Price", secondary_y=False)
fig.update_yaxes(title_text="Ether Price", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["n_vessels"], name="Number of Troves"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["supply_USDV"], name="VUSD Supply"),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of Trove Numbers and VUSD Supply")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Number of Troves", secondary_y=False)
fig.update_yaxes(title_text="VUSD Supply", secondary_y=True)
fig.show()

fig = make_subplots(rows=2, cols=1)
fig.add_trace(
    go.Scatter(
        x=data.index / 720,
        y=data["n_open"],
        name="Number of Troves Opened",
        mode="markers",
    ),
    row=1,
    col=1,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720,
        y=data["n_close"],
        name="Number of Troves Closed",
        mode="markers",
    ),
    row=2,
    col=1,
    secondary_y=False,
)
fig.update_layout(title_text="Dynamics of Number of Troves Opened and Closed")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Troves Opened", row=1, col=1)
fig.update_yaxes(title_text="Troves Closed", row=2, col=1)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(
        x=data.index / 720,
        y=data["n_liquidate"],
        name="Number of Liquidated Troves",
        mode="markers",
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720,
        y=data["n_redempt"],
        name="Number of Redempted Troves",
        mode="markers",
    ),
    secondary_y=False,
)
fig.update_layout(title_text="Dynamics of Number of Liquidated and Redempted Troves")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Number of Liquidated Troves", secondary_y=False)
fig.update_yaxes(title_text="Number of Redempted Troves", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["liquidity"], name="Liquidity Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["stability"], name="Stability Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=100 * data["redemption_pool"], name="100*Redemption Pool"
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=data["return_stability"], name="Return of Stability Pool"
    ),
    secondary_y=True,
)
fig.update_layout(
    title_text="Dynamics of Liquidity, Stability, Redemption Pools and Return of Stability Pool"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Size of Pools", secondary_y=False)
fig.update_yaxes(title_text="Return", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["airdrop_gain"], name="Airdrop Gain"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["liquidation_gain"], name="Liquidation Gain"),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of Airdrop and Liquidation Gain")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Airdrop Gain", secondary_y=False)
fig.update_yaxes(title_text="Liquidation Gain", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["issuance_fee"], name="Issuance Fee"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["redemption_fee"], name="Redemption Fee"),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of Issuance Fee and Redemption Fee")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Issuance Fee", secondary_y=False)
fig.update_yaxes(title_text="Redemption Fee", secondary_y=True)
fig.show()

# linevis(data, 'annualized_earning')

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["price_GRVT"], name="GRVT Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["MC_GRVT"], name="GRVT Market Cap"),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of the Price and Market Cap of GRVT")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="GRVT Price", secondary_y=False)
fig.update_yaxes(title_text="GRVT Market Cap", secondary_y=True)
fig.show()


def vessel_histogram(measure):
    fig = px.histogram(vessels, x=measure, title="Distribution of " + measure, nbins=25)
    fig.show()


vessels

vessel_histogram("Ether_Quantity")
vessel_histogram("CR_initial")
vessel_histogram("Supply")
vessel_histogram("Rational_inattention")
vessel_histogram("CR_current")

import matplotlib.pyplot as plt

plt.plot(vessels["Ether_Quantity"])
plt.show()

plt.plot(vessels["CR_initial"])
plt.show()

plt.plot(vessels["Supply"])
plt.show()

plt.plot(vessels["CR_current"])
plt.show()

data.describe()

"""new policy function

issuance fee = redemption fee = base rate

#**Simulation with Policy Function**
"""

# Defining Initials
initials = {
    "Price_USDV": [1.00],
    "Price_Ether": [price_ether_initial],
    "n_open": [initial_open],
    "n_close": [0],
    "n_liquidate": [0],
    "n_redempt": [0],
    "n_vessels": [initial_open],
    "stability": [0],
    "liquidity": [0],
    "redemption_pool": [0],
    "supply_USDV": [0],
    "return_stability": [initial_return],
    "airdrop_gain": [0],
    "liquidation_gain": [0],
    "issuance_fee": [0],
    "redemption_fee": [0],
    "price_GRVT": [price_GRVT_initial],
    "MC_GRVT": [0],
    "annualized_earning": [0],
    "base_rate": [base_rate_initial],
}
data2 = pd.DataFrame(initials)
vessels2 = pd.DataFrame(
    {
        "Ether_Price": [],
        "Ether_Quantity": [],
        "CR_initial": [],
        "Supply": [],
        "Rational_inattention": [],
        "CR_current": [],
    }
)
result_open = open_vessels(vessels2, 0, data2["Price_USDV"][0])
vessels2 = result_open[0]
issuance_USDV_open = result_open[2]
data2.loc[0, "issuance_fee"] = issuance_USDV_open * initials["Price_USDV"][0]
data2.loc[0, "supply_USDV"] = vessels2["Supply"].sum()
data2.loc[0, "liquidity"] = 0.5 * vessels2["Supply"].sum()
data2.loc[0, "stability"] = 0.5 * vessels2["Supply"].sum()

# Simulation Process
for index in range(1, n_sim):
    # exogenous ether price input
    price_ether_current = price_ether[index]
    vessels2["Ether_Price"] = price_ether_current
    price_USDV_previous = data2.loc[index - 1, "Price_USDV"]
    price_GRVT_previous = data2.loc[index - 1, "price_GRVT"]

    # policy function determines base rate
    base_rate_current = 0.98 * data2.loc[index - 1, "base_rate"] + 0.5 * (
        data2.loc[index - 1, "redemption_pool"] / vessels2["Supply"].sum()
    )
    rate_issuance = base_rate_current
    rate_redemption = base_rate_current

    # vessel liquidation & return of stability pool
    result_liquidation = liquidate_vessels(vessels2, index, data2)
    vessels2 = result_liquidation[0]
    return_stability = result_liquidation[1]
    debt_liquidated = result_liquidation[2]
    ether_liquidated = result_liquidation[3]
    liquidation_gain = result_liquidation[4]
    airdrop_gain = result_liquidation[5]
    n_liquidate = result_liquidation[6]

    # close vessels
    result_close = close_vessels(vessels2, index, price_USDV_previous)
    vessels2 = result_close[0]
    n_close = result_close[1]
    # if n_close<0:
    #  break

    # adjust vessels
    result_adjustment = adjust_vessels(vessels2, index)
    vessels2 = result_adjustment[0]
    issuance_USDV_adjust = result_adjustment[1]

    # open vessels
    result_open = open_vessels(vessels2, index, price_USDV_previous)
    vessels2 = result_open[0]
    n_open = result_open[1]
    issuance_USDV_open = result_open[2]

    # Stability Pool
    stability_pool = stability_update(
        data2.loc[index - 1, "stability"], return_stability, index
    )[0]

    # Calculating Price, Liquidity Pool, and Redemption
    result_price = price_stabilizer(vessels2, index, data2, stability_pool, n_open)
    price_USDV_current = result_price[0]
    liquidity_pool = result_price[1]
    vessels2 = result_price[2]
    issuance_USDV_stabilizer = result_price[3]
    redemption_fee = result_price[4]
    n_redempt = result_price[5]
    redemption_pool = result_price[6]
    n_open = result_price[7]
    if liquidity_pool < 0:
        break

    # GRVT Market
    result_GRVT = GRVT_market(index, data2)
    price_GRVT_current = result_GRVT[0]
    annualized_earning = result_GRVT[1]
    MC_GRVT_current = result_GRVT[2]

    # Summary
    issuance_fee = price_USDV_current * (
        issuance_USDV_adjust + issuance_USDV_open + issuance_USDV_stabilizer
    )
    n_vessels = vessels2.shape[0]
    supply_USDV = vessels2["Supply"].sum()
    if index >= month:
        price_GRVT.append(price_GRVT_current)

    new_row = {
        "Price_USDV": float(price_USDV_current),
        "Price_Ether": float(price_ether_current),
        "n_open": float(n_open),
        "n_close": float(n_close),
        "n_liquidate": float(n_liquidate),
        "n_redempt": float(n_redempt),
        "n_vessels": float(n_vessels),
        "stability": float(stability_pool),
        "liquidity": float(liquidity_pool),
        "redemption_pool": float(redemption_pool),
        "supply_USDV": float(supply_USDV),
        "issuance_fee": float(issuance_fee),
        "redemption_fee": float(redemption_fee),
        "airdrop_gain": float(airdrop_gain),
        "liquidation_gain": float(liquidation_gain),
        "return_stability": float(return_stability),
        "annualized_earning": float(annualized_earning),
        "MC_GRVT": float(MC_GRVT_current),
        "price_GRVT": float(price_GRVT_current),
        "base_rate": float(base_rate_current),
    }
    data2 = data2.append(new_row, ignore_index=True)
    if price_USDV_current < 0:
        break

data2

"""#**Exhibition Part 2**"""

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["Price_USDV"], name="VUSD Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["Price_Ether"], name="Ether Price"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["Price_USDV"],
        name="VUSD Price New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.update_layout(title_text="Price Dynamics of VUSD and Ether")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="VUSD Price", secondary_y=False)
fig.update_yaxes(title_text="Ether Price", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["n_vessels"], name="Number of Troves"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["supply_USDV"], name="VUSD Supply"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["n_vessels"],
        name="Number of Troves New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["supply_USDV"],
        name="VUSD Supply New",
        line=dict(dash="dot"),
    ),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of Trove Numbers and VUSD Supply")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Number of Troves", secondary_y=False)
fig.update_yaxes(title_text="VUSD Supply", secondary_y=True)
fig.show()

fig = make_subplots(rows=2, cols=2)
fig.add_trace(
    go.Scatter(
        x=data.index / 720,
        y=data["n_open"],
        name="Number of Troves Opened",
        mode="markers",
    ),
    row=1,
    col=1,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720,
        y=data["n_close"],
        name="Number of Troves Closed",
        mode="markers",
    ),
    row=2,
    col=1,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["n_open"],
        name="Number of Troves Opened New",
        mode="markers",
    ),
    row=1,
    col=2,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["n_close"],
        name="Number of Troves Closed New",
        mode="markers",
    ),
    row=2,
    col=2,
    secondary_y=False,
)
fig.update_layout(title_text="Dynamics of Number of Troves Opened and Closed")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Troves Opened", row=1, col=1)
fig.update_yaxes(title_text="Troves Closed", row=2, col=1)
fig.show()

fig = make_subplots(rows=2, cols=1)
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=data["n_liquidate"], name="Number of Liquidated Troves"
    ),
    row=1,
    col=1,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=data["n_redempt"], name="Number of Redempted Troves"
    ),
    row=2,
    col=1,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["n_liquidate"],
        name="Number of Liquidated Troves New",
        line=dict(dash="dot"),
    ),
    row=1,
    col=1,
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["n_redempt"],
        name="Number of Redempted Troves New",
        line=dict(dash="dot"),
    ),
    row=2,
    col=1,
    secondary_y=False,
)
fig.update_layout(title_text="Dynamics of Number of Liquidated and Redempted Troves")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Troves Liquidated", row=1, col=1)
fig.update_yaxes(title_text="Troves Redempted", row=2, col=1)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["liquidity"], name="Liquidity Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["stability"], name="Stability Pool"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=100 * data["redemption_pool"], name="100*Redemption Pool"
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["liquidity"],
        name="Liquidity Pool New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["stability"],
        name="Stability Pool New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=100 * data2["redemption_pool"],
        name="100*Redemption Pool New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Liquidity, Stability, Redemption Pools and Return of Stability Pool"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Size of Pools", secondary_y=False)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=data["return_stability"], name="Return of Stability Pool"
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["return_stability"],
        name="Return of Stability Pool New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.update_layout(
    title_text="Dynamics of Liquidity, Stability, Redemption Pools and Return of Stability Pool"
)
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Return", secondary_y=False)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["airdrop_gain"], name="Airdrop Gain"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["liquidation_gain"], name="Liquidation Gain"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["airdrop_gain"],
        name="Airdrop Gain New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["liquidation_gain"],
        name="Liquidation Gain New",
        line=dict(dash="dot"),
    ),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of Airdrop and Liquidation Gain")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Airdrop Gain", secondary_y=False)
fig.update_yaxes(title_text="Liquidation Gain", secondary_y=True)
fig.show()

fig = make_subplots(rows=2, cols=1)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["issuance_fee"], name="Issuance Fee"),
    row=1,
    col=1,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["redemption_fee"], name="Redemption Fee"),
    row=2,
    col=1,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["issuance_fee"],
        name="Issuance Fee New",
        line=dict(dash="dot"),
    ),
    row=1,
    col=1,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["redemption_fee"],
        name="Redemption Fee New",
        line=dict(dash="dot"),
    ),
    row=2,
    col=1,
)
fig.update_layout(title_text="Dynamics of Issuance Fee and Redemption Fee")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Issuance Fee", secondary_y=False, row=1, col=1)
fig.update_yaxes(title_text="Redemption Fee", secondary_y=False, row=2, col=1)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(
        x=data.index / 720, y=data["annualized_earning"], name="Annualized Earning"
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["annualized_earning"],
        name="Annualized Earning New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.update_layout(title_text="Dynamics of Annualized Earning")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Annualized Earning", secondary_y=False)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["price_GRVT"], name="GRVT Price"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data.index / 720, y=data["MC_GRVT"], name="GRVT Market Cap"),
    secondary_y=True,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["price_GRVT"],
        name="GRVT Price New",
        line=dict(dash="dot"),
    ),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(
        x=data2.index / 720,
        y=data2["MC_GRVT"],
        name="GRVT Market Cap New",
        line=dict(dash="dot"),
    ),
    secondary_y=True,
)
fig.update_layout(title_text="Dynamics of the Price and Market Cap of GRVT")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="GRVT Price", secondary_y=False)
fig.update_yaxes(title_text="GRVT Market Cap", secondary_y=True)
fig.show()

fig = make_subplots(specs=[[{"secondary_y": True}]])
fig.add_trace(
    go.Scatter(x=data.index / 720, y=[0.01] * n_sim, name="Base Rate"),
    secondary_y=False,
)
fig.add_trace(
    go.Scatter(x=data2.index / 720, y=data2["base_rate"], name="Base Rate New"),
    secondary_y=False,
)
fig.update_layout(title_text="Dynamics of Issuance Fee and Redemption Fee")
fig.update_xaxes(tick0=0, dtick=1, title_text="Month")
fig.update_yaxes(title_text="Issuance Fee", secondary_y=False)
fig.update_yaxes(title_text="Redemption Fee", secondary_y=True)
fig.show()


def vessel2_histogram(measure):
    fig = px.histogram(vessels2, x=measure, title="Distribution of " + measure, nbins=25)
    fig.show()


vessel2_histogram("Ether_Quantity")
vessel2_histogram("CR_initial")
vessel2_histogram("Supply")
vessel2_histogram("Rational_inattention")
vessel2_histogram("CR_current")
